"""
腾讯一面
计算x的n次方，不得使用库，注意算法效率
解决思路：快速幂算法， 快速傅里叶变换(FFT)
"""
# 快速幂算法
def qPow(a,n):
    if(n==0):
        return 1
    ans = 1
    while(n):  # 计算时间复杂度，循环次数：n除以多少个2会等于0, 即log2n
        if (n&1): #若n 为奇数
            ans = a*ans
        a = a*a
        n>>=1 # 右移一位等价于除以2
    return ans
print("快速幂结果：",qPow(5,5))


# # 引申：快速乘算法
# # 求a*b%m , 当a*b结果很大，乘完后可能会溢出
# # 解决思路：采用二进制实现快速乘
# # 1001101∗11010=1001101∗2^4∗1+1001101∗2^3∗1+1001101∗2^2∗0+1001101∗2^1∗1+1001101∗2^0∗0  我们对上面的每一个加项进行取模，在加起来，就不会溢出了
def qMul(a,b,m):
    sum = 0
    k = 1
    while(b):
        if (b&1): #若b 为奇数
            sum = (sum+a*k)%m
        k = (k<<1)%m
        b>>=1 # 右移一位等价于除以2
    return sum
print("快速乘结果：",qMul(5,7,4))


## 在不使用 * ，/  亦不使用现成函数的情况下 实现整数乘法，注意计算效率、内存泄漏等问题
## 解决思路：用与运算
def mul(a,b):
    ans = 0
    k =0
    while(b):
        if(b&1): # 若b 为奇数,即判断每一位是否为1
            ans = ans + (a << k)  # 加优先级高于移位
        k +=1
        b>>=1
    return ans
print("位运算实现乘法结果：",mul(54,24))

## 除法
def div(a,b):
    k = 0
    while(a>b):
        a = a-b
        k +=1
    return k,a
print(div(55,5))
